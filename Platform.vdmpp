class Platform

types

private Purses= set of Purse;
private Name = seq of char;
private Surname = seq of char; 
private Sex = <Woman> | <Man> | <Indefinite>;
private DateBirth = nat;
private Nationality= seq of char;
private Country = seq of char;
private Address = seq of char;
private Customer= Markets`CustomerId;
private Stock= Markets`Stocks;

public AccountId = nat1;

instance variables

private purses : Purses := {};

operations

protected OrderSender: Orders`CustomerId * Orders`StockId * Orders`OrdType * real * Markets`Stocks ==> int
OrderSender(cId, stock, type, qt, stName) ==
(
dcl purseItem: set of Purse,
    price: Orders`Price;

purseItem := {x | x in set purses & x.purse.id= cId};
price := Markets`prices(stName);
if purseItem`DecreaseBal(price * qt)
    then if purseItem`IncreaseAsset(stock, qt)
        then if Orders`SendOrder(cId, stock, type, qt, price)
                then return 0
                else return 3
        else return 2
    else return 1;
)
pre {x | x in set purses & x.purse.id= cId} <> {};

protected OrderDeleter: Orders`OrderInfo ==> ()
OrderDeleter(info) ==
(
dcl purseItem: set of Purse,
    price: Orders`Price;

purseItem := {x | x in set purses & x.purse.id = info.ordId};
price := Markets`prices(info.sId);
purseItem`IncreaseBal(price * info.qt);
purseItem`DecreaseAsset(info.sId , info.qt);
Orders`DeleteOrder(info);
)
pre {x | x in set purses & x.purse.id= info.ordId} <> {};

private Deposit: Name * Surname * Purse`PurseAccount * real ==> bool
Deposit(nam, sur, purse, amount) ==
(
dcl purseId: Purse`UserId,
    purseItem: set of Purse;

purseId := purse.id;
purseItem := {x | x in set purses & x.purse.user.account.name = nam and x.purse.user.account.surname= sur and x.purse.id= purseId};
if purse.id = 0
    then return false
    else purseItem := purseItem`IncreaseBal(amount);
         return true;
)
pre {x | x in set purses & x.purse.user.account.name = nam and x.purse.user.account.surname = sur and x.purse.id= purse.id} <> {};

private Withdraw: Name * Surname * Purse`PurseAccount * real ==> bool
Withdraw(nam, sur, purse, amount) ==
(
dcl purseId: Purse`UserId,
    purseItem: set of Purse;

purseId := purse.id;
purseItem := {x | x in set purses & x.purse.user.account.name = nam and x.purse.user.account.surname = sur and x.purse.id= purseId};
if purse.id = 0
    then 
        return false
    else 
        purseItem := purseItem`DecreaseBal(amount);
        return true;
)
pre {x | x in set purses & x.purse.user.account.name = nam and x.purse.user.account.surname = sur and x.purse.id = purse.id} <> {};

private CreateUser: Name * Surname * Sex * DateBirth * Nationality * Country * Address ==> ()
CreateUser(nam, sur, s , db, nation, c, addr) ==
(
dcl wallet : set of Purse,
    id : AccountId;

id := CreateId();

wallet := {new Purse(
                    id,
                    nam,
                    sur,
                    s,
                    db,
                    nation,
                    c,
                    addr)};
purses := wallet union purses;   
);

private DeleteUser: Name * Surname * Purse`PurseAccount ==> bool
DeleteUser(nam, sur, purse) ==
(
dcl purseId: Purse`UserId,
    purseCheck: set of Purse;

purseId := purse.id;
purseCheck := {x | x in set purses & x.purse.user.account.name= nam and x.purse.user.account.surname = sur and x.purse.id = purseId};
if purseCheck= {}
    then 
        return false
    else 
        purses := purses \ purseCheck;
        return true;
);

protected CreateId: () ==> AccountId
CreateId() ==
(  
  dcl tempId : AccountId;

  tempId := MATH`rand(36);

  if tempId > 0 and forall x in set purses & tempId <> x.purse.id  
    then 
        return tempId
    else 
        CreateId();
);

end Platform